import numpy as np
import matplotlib.pyplot as plt
from sympy import symbols, integrate, parse_expr, pi, Abs
from mpl_toolkits.mplot3d import Axes3D

x = symbols('x')

def calcular_area(f, a, b):
    return integrate(f, (x, a, b))

def calcular_area_entre_funciones(f, g, a, b):
    return integrate(Abs(f - g), (x, a, b))

def calcular_volumen_proyeccion(f, a, b):
    return pi * integrate(f**2, (x, a, b))

def evaluar_funcion_segura(expr, valores):
    resultado = []
    for val in valores:
        res = expr.evalf(subs={x: val})
        if res.is_real:
            resultado.append(float(res))
        else:
            resultado.append(np.nan)
    return resultado

def mostrar_graficas_2d(f_expr, a, b, mostrar_area=True, eje='x', g_expr=None):
    fig, axs = plt.subplots(1, 2, figsize=(12, 5))

    x_vals = np.linspace(float(a) - 1, float(b) + 1, 500)
    f_vals = evaluar_funcion_segura(f_expr, x_vals)
    g_vals = evaluar_funcion_segura(g_expr, x_vals) if g_expr else None

    x_area = np.linspace(float(a), float(b), 500)
    f_area = evaluar_funcion_segura(f_expr, x_area)
    g_area = evaluar_funcion_segura(g_expr, x_area) if g_expr else None

    axs[0].plot(x_vals, f_vals, color='blue', label=f'f(x) = {f_expr}')
    if g_expr:
        axs[0].plot(x_vals, g_vals, color='red', linestyle='--', label=f'g(x) = {g_expr}')
    axs[0].set_title("Funciones sin √°rea")
    axs[0].set_xlabel("x")
    axs[0].set_ylabel("y")
    axs[0].grid(True)
    axs[0].legend()

    axs[1].plot(x_vals, f_vals, color='blue', label=f'f(x) = {f_expr}')
    if g_expr:
        axs[1].plot(x_vals, g_vals, color='red', linestyle='--', label=f'g(x) = {g_expr}')
        axs[1].fill_between(x_area, f_area, g_area, color='violet', alpha=0.5, label="√Årea entre funciones")
        axs[1].set_title("√Årea entre f(x) y g(x)")
    else:
        if mostrar_area:
            axs[1].fill_between(x_area, f_area, color='skyblue', alpha=0.5, label="√Årea bajo la curva")
            axs[1].set_title("√Årea bajo la curva")
        else:
            axs[1].fill_between(x_area, [0]*len(x_area), f_area, color='orange', alpha=0.5, label="Volumen proyectado")
            axs[1].set_title("Proyecci√≥n del volumen")

    axs[1].set_xlabel("x")
    axs[1].set_ylabel("y")
    axs[1].grid(True)
    axs[1].legend()
    plt.tight_layout()
    plt.show()

def mostrar_volumen_3d(f_expr, a, b, eje='x'):
    theta = np.linspace(0, 2 * np.pi, 100)

    if eje == 'x':
        x_vals = np.linspace(float(a), float(b), 100)
        x_grid, theta_grid = np.meshgrid(x_vals, theta)
        f_fun = np.vectorize(lambda val: float(f_expr.evalf(subs={x: val})) if f_expr.evalf(subs={x: val}).is_real else np.nan)
        r_vals = f_fun(x_vals)
        r_grid, _ = np.meshgrid(r_vals, theta)

        X = x_grid
        Y = r_grid * np.cos(theta_grid)
        Z = r_grid * np.sin(theta_grid)

    elif eje == 'y':
        y_vals = np.linspace(float(a), float(b), 100)
        y_grid, theta_grid = np.meshgrid(y_vals, theta)
        f_fun = np.vectorize(lambda val: float(f_expr.evalf(subs={x: val})) if f_expr.evalf(subs={x: val}).is_real else np.nan)
        r_vals = f_fun(y_vals)
        r_grid, _ = np.meshgrid(r_vals, theta)

        X = r_grid * np.cos(theta_grid)
        Z = r_grid * np.sin(theta_grid)
        Y = y_grid

    fig = plt.figure(figsize=(10, 6))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(X, Y, Z, cmap='plasma', alpha=0.8, edgecolor='none')

    ax.set_title(f"S√≥lido de revoluci√≥n en 3D (eje {eje})")
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_zlabel("z")
    plt.tight_layout()
    plt.show()

def menu_integrales_definidas():
    print("\n=== C√ÅLCULO DE INTEGRALES DEFINIDAS ===")
    print("1. √Årea bajo una curva")
    print("2. √Årea entre dos funciones")
    print("3. S√≥lido de revoluci√≥n en 3D")

    opcion = input("Selecciona una opci√≥n (1 a 3): ")

    if opcion == '1':
        expr_str = input("\nIngresa la funci√≥n f(x): ")
        a = float(input("L√≠mite inferior a: "))
        b = float(input("L√≠mite superior b: "))
        f_expr = parse_expr(expr_str)
        area = calcular_area(f_expr, a, b)
        print(f"‚úÖ √Årea entre x = {a} y x = {b} es: {area} ‚âà {float(area):.5f}")
        mostrar_graficas_2d(f_expr, a, b, mostrar_area=True)

    elif opcion == '2':
        expr1 = input("\nIngresa la primera funci√≥n f(x): ")
        expr2 = input("Ingresa la segunda funci√≥n g(x): ")
        a = float(input("L√≠mite inferior a: "))
        b = float(input("L√≠mite superior b: "))
        f_expr = parse_expr(expr1)
        g_expr = parse_expr(expr2)
        area = calcular_area_entre_funciones(f_expr, g_expr, a, b)
        print(f"‚úÖ √Årea entre f(x) y g(x) en [{a}, {b}] es: {area} ‚âà {float(area):.5f}")
        mostrar_graficas_2d(f_expr, a, b, mostrar_area=True, g_expr=g_expr)

    elif opcion == '3':
        expr_str = input("\nIngresa la funci√≥n f(x): ")
        a = float(input("L√≠mite inferior a: "))
        b = float(input("L√≠mite superior b: "))
        eje = input("üëâ ¬øSobre qu√© eje deseas visualizar el s√≥lido 3D? (x o y): ").strip().lower()
        f_expr = parse_expr(expr_str)
        volumen = calcular_volumen_proyeccion(f_expr, a, b)
        print(f"‚úÖ Volumen (te√≥rico) entre {a} y {b} es: {volumen} ‚âà {float(volumen):.5f}")
        mostrar_volumen_3d(f_expr, a, b, eje=eje)

    else:
        print("‚ùå Opci√≥n inv√°lida.")

def main():
    print("====== C√ÅLCULO DE √ÅREAS Y VOL√öMENES MEDIANTE INTEGRALES ======")
    menu_integrales_definidas()

if __name__ == "__main__":
    main()